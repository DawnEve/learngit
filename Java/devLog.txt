review Java

===========================================
v0.0.1 安装eclipse环境

Build id: 20100617-1415 不行！高亮代码，但是不能运行！
Version: Neon.1 Release (4.6.1) Build id: 20160913-0900 不高亮，不运行。

代码不亮无解。
但是代码高亮了，不运行有姐。
重新新建java项目即可。
比较了一下，发现需要
 .project
 .classpath
两个文件！
write in:http://zhengzhi2014.blog.163.com/blog/static/227196154201692984845865/



===========================================
v0.0.2 Java变量、运算符、流程控制
    《21天学通Java》(P1-P96)
    for循环中循环数字在循环结束消失，而while循环则在循环结束后继续有效。
    
===========================================
v0.0.3 Java数组  《21天学通Java》(P97-P111)
(1)语法：for(int x:arr){///xxx}
        报错：Syntax error, 'for each' statements are only available if source level is 1.5 or greater
        
        解决方法：
        在eclipse中菜单Window----preferences----java-----compiler把右边中的Compiler
        compliance level改为1.6
        右击项目，修改properties，找到java
        compiler修改compiler compliance level为1.6

(2)数组遍历、复制、求最值、冒泡法排序、二分法查找
    for(int x: arr2){//todo sth;}

(3)排序可以自己实现，或者引用类 import java.util.Arrays;
        数组的工具类:java.util.Arrays中的工具方法. 

(4)二维数组
int[][] arr=new int[3][2];//define
    //set 3 one-d array, each has 2 element;
    数组是按照地址传递的，
    - 在栈中有一个地址，指向堆内存。
    - 堆内有一个区域保存第一维度共3个数组的地址；
    - 这三个地址又指向第二个堆内存，分别是是3个数组，每个数组2个元素。







===========================================
v0.0.4 OOP  《21天学通Java》(P112-P145)
  类和对象
  + 类是图纸，对象是依照图纸盖好的房子。
    - 类是抽象的，对象是具体的。
    - 可以单继承，也可以多层继承。
    - 类包括：成员变量（类中定义的）、成员方法， 局部变量（方法中定义的）、

    •成员变量可以被public、protected、default、private、static、final修饰符修饰。 
    •局部变量可以被final修饰符修饰，但不能修饰为public、protected、default、private、static。 
    
    •成员变量是在堆里进行创建的，而局部变量是在栈里进行创建的。 
    
    •成员变量是系统默认值。 
    •局部变量没有系统默认值，必须手动赋值。

  + 类设计的技巧：
    - 先要明确这个类需要完成的功能。不要加入不相关的变量或方法。

使用构造器时需要记住：
http://longying2008.iteye.com/blog/1535722
1.构造器必须与类同名（如果一个源文件中有多个类，那么构造器必须与公共类同名）
2.每个类可以有一个以上的构造器
3.构造器可以有0个、1个或1个以上的参数
4.构造器没有返回值
5.构造器总是伴随着new操作一起调用 

OOP三大特征：
　　封装(Encapsulation);
　　继承(Inheritance);
　　多态(Polymorphism);

　　(1)封装是指将对象的实现细节隐藏起来，然后通过公共的方法来向外暴露该对象的功能。
　　(2)继承是面向对象实现软件复用的重要手段，
当子类继承父类后，子类是一种特殊的父类，能直接或间接获得父类里的成员。
　　(3)多态是可以直接把子类对象赋给父类变量，但是运行时依然表现出子类的行为特征，
这意味着同一类型的对象在运行时可能表现出不同的行为特征。


	package
	
当创建了一个包时就要引入一个包，引入一个包的关键字为import，语法为：
    - import 包名.*; 
    - import 包名.类名;


所谓静态引入就是引入包中的静态成员变量和静态方法。
静态引入的关键字为static，静态的其他内容将将在后面的小结进行讲解。静态引入的语法为：
	- import static 包名.aaa.*; 
	- import static 包名.aaa.方法名称;


	引用另一个包中类中的静态方法。import static 包.类.静态方法







===========================================
v0.0.4-1 OOP 继承、重写、重载、抽象  《21天学通Java》(P146-P195)
	封装展现了接口，隐藏了细节。
	被final关键字修饰的成员变量是不会被初始化的，成员变量必须要有初始值。
	被final关键字修饰的局部变量如果在创建的时候没有对其赋值，那么在使用前还是可以对其赋值的。
	
	静态修饰符static，所谓静态就是在内存中只能有一份。static能修饰变量、方法、语句块、内部类，

	static 成员变量类型 成员变量名称。
	static String color = "绿色";

	在Java里用static final两种关键字来修饰成员变量。

	继承
		- 在此基础上讨论重写、重载、重写与重载之间的区别，
		- 以及多态和如何灵活运用final、abstract等概念，因此学好这些概念是灵活运用多态的基石。
		- Java提供了单一继承，通过接口可以实现多重继承。

问题：
	• 了解什么是继承和继承如何使用。 
	• 掌握声明成员变量的修饰符。 
	• 熟练掌握方法的重写和重载。 
	• 了解枚举、反射和泛型等热门技术。


构造器：
	子类的无参构造器默认是调用的父类的无参构造器。


修饰符：主要有4个修饰符：public、private、default、protected

重写是基于继承的 @Override
	静态方法是不能重写的

覆盖是用于父类和子类之间。
重载是用在同一个类中，有相同的方法名，但参数不一样。


重写的关键字是override，重载的关键字为overload，重写、重载、覆盖都是基于继承的关系。
当继承的关系发生了，想用父类的方法就用super关键字来引用，
如果想用新的方法了就重写下，来完成新的功能需要。

对覆盖总结如下几点： 
	•覆盖的方法的参数列表必须要和被覆盖的方法的参数列表完全相同，才能达到覆盖的效果。 
	•覆盖的方法的返回值必须和被覆盖的方法的返回值一致。 
	•覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类。 
	•被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。

对重载总结如下： 
	•使用重载时只能定义不同的参数列表。
	•不能通过重载的方法的返回类型、访问权限和抛出的异常来进行方法的重载。 

对重写总结如下：
	•重写的方法存在于父类中，也存在于子类中。 
	•重写的方法在运行期采用多态的形式。
	•重写的方法不能比被重写的方法有更高的访问限制。 
	•重写的方法不能比被重写的方法有更多的异常。


重写toString
	@Override
	public String toString(){
		return "class Person: name="+this.name;
	}
	
重写equals	
	@Override
	public boolean equals(Object obj){
		return this==obj;
	}

抽象类和抽象方法
	abstract public void cry(); //抽象方法
	至少有一个抽象方法的类叫抽象方法。
	
	







===========================================
v0.0.4-2 OOP 多态  《21天学通Java》(P196-P198)
http://www.jb51.net/article/34413.htm
+ 方法的重写Overriding和重载Overloading是Java多态性的不同表现。
+ 重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。

static修饰的方法和final修饰的方法是在编译期绑定的；
而其他的方法是在运行期绑定，动态地判断是什么类型。 
	•多态是基于继承的，是类和接口相结合来实现的。
	- 从一定角度来看，封装和继承几乎都是为多态而准备的。


下面是多态存在的三个必要条件，要求大家做梦时都能背出来！
	多态存在的三个必要条件
	一、要有继承；
	二、要有重写；
	三、父类引用指向子类对象。

Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。

多态的弊端: 只能使用父类的引用访问父类的成员


多态分两种：
(1)   编译时多态（设计时多态）：方法重载。
(2)   运行时多态：JAVA运行时系统根据调用该方法的实例的类型来决定选择调用哪个方法则被称为运行时多态。
（我们平时说得多的是运行时多态，所以多态主要也是指运行时多态）


方法调用的优先问题 ，优先级由高到低依次为：？
	this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。
(1)使用父类类型的引用指向子类的对象；
(2)引用只能调用父类中定义的方法和变量；
(3)子类中重写了父类的一个方法，那么在调用该方法时，将会调用子类的这个方法。
	动态连接、动态调用。
(4)变量不能被重写（覆盖）。重写只针对方法，如果子类“重写”了父类的变量，那么编译时会报错。








===========================================
v0.0.4-3 OOP 枚举类  《21天学通Java》(P198)
	枚举的本质是类
	定义枚举：代替常量使用很方便！之前 常量大都是用public static final 来定义的。
	http://blog.csdn.net/qq_27093465/article/details/52180865

enum Grade{
	w1,w2,w3,w4,w5,w6,w7
}









===========================================
v0.0.4-4 OOP 反射机制  《21天学通Java》(P199-P)
Java 语言的反射（Reflection）机制。
反射机制就是起到放大镜的效果，可以通过类名，加载这个类，显示出这个类的方法等信息。

http://lavasoft.blog.51cto.com/62575/43218/
Java 反射机制主要提供了以下功能：
	在运行时判断任意一个对象所属的类。
	在运行时构造任意一个类的对象。
	在运行时判断任意一个类所具有的成员变量和方法。
	在运行时调用任意一个对象的方法。
	
java中，一切皆对象。	
	
在JDK中，主要由以下类来实现Java反射机制，这些类都位于java.lang.reflect包中：
Class类：代表一个类。
Field 类：代表类的成员变量（成员变量也称为类的属性）。
Method类：代表类的方法。
Constructor 类：代表类的构造方法。
Array类：提供了动态创建数组，以及访问数组的元素的静态方法。


===========================================
v0.0.4-5 OOP 反射机制2
当你知道了java的反射机制后，以后当你接触到java的动态代理时就不会茫然了。

http://www.cnblogs.com/hxsyl/archive/2013/03/23/2977593.html
http://azrael6619.iteye.com/blog/429797


方法的获取，执行：
Method method = clazz.getMethod(methodName,argsClass);  
method.invoke(owner, args);  

执行静态方法：
method.invoke(null, args);
//invoke的一个参数是null，因为这是静态方法，不需要借助实例运行。

获取实例：
Constructor cons = newoneClass.getConstructor(argsClass);  
return cons.newInstance(args); 










===========================================
v0.0.4-6 OOP 泛型(SDK1.5+) 《21天学通Java》(P200-P203)
官方：https://docs.oracle.com/javase/tutorial/java/generics/index.html

在Java中，通过泛型可以给开发带来方便，通过参数的指定，可以改变其类型。
Java 泛型的类型参数之实际类型在编译时会被消除。
 
优点：
 - 能使代码看起来灵活；容易管理，不容易产生错误。 
 - 使用泛型能使代码量减少，能产生很多公共代码。
 - 使用泛型在代码编译的时候能进行类型的检查并自动转换，使代码的运行效率得到提高。 
 - 使用泛型在编译进行自动转换的时候出现了错误，会进行错误提示。 
 - 使用泛型的时候参数只能是类的类型，不能是简单类型。
 - 使用泛型的时候参数可以有多个。
 - 使用泛型的时候参数也能继承别的类型。

泛型类型就是List<T>和Map<T, T>.


泛型有很多种，类泛型，接口泛型，方法泛型 http://swiftlet.net/archives/1964

问题：JAVA泛型中的有界类型(extends super)， ? extends和? super的区别.
//TODO http://blog.csdn.net/daniel_h1986/article/details/5708605
	- List默认就是List<? entends Object>
	- 小结一下就是：上界add方法受限，下界get方法受限。


擦除也许泛型最具挑战性的方面是擦除（erasure），这是 Java 语言中泛型实现的底层技术。

多重限制的语法是用“与”符号分隔限制：
class C<T extends Comparable<? super T>&Serializable>





===========================================
v0.0.4-7 OOP 接口和抽象类 《21天学通Java》(P204-P223)
抽象类、多态特性；

目标：
•会定义接口和访问接口中的变量。 
•熟练掌握接口的使用。 
•了解接口和抽象类的区别。 
•了解接口的多态问题。 
•熟练掌握使用instanceof判断类型。


接口内的变量都是public static final类型的，可以当做常量使用。
接口里方法全为抽象。
接口里的方法默认且必须是被修饰为public、abstract类型，不能是static、final类型。

冲突处理：实现多个接口时，变量、方法重名怎么办？
	变量当常量，著名接口.变量即可。
	方法重名就不用管了？反正不报错。
	
抽象类与接口区别？	
java 类型信息 instanceof 和 isInstance区别?

为什么无关的类不能使用instanceof判断？

面总结使用instanceof有哪些规则。
	•instanceof关键字不能比较基本类型的数据。
	•instanceof关键字可以对对象和接口使用。
	•instanceof关键字的比较是基于多态的。
	•不推荐使用instanceof关键字，要多多应用多态。
	•instanceof关键字右边比较的类型只能为类和接口。

可比较接口，序列化接口//TODO
Comparable 和 Serializable。









===========================================
v0.0.4-8 OOP 构造器  《21天学通Java》(P224-P239)

构造器用法
•构造器可以使用的修饰符有public、protected、default、private，不写即为default类型的。 
•构造器的名称必须要和类的名称相同。 
•不能有返回值，void也不行。
•构造器的参数可有可无。有一个也可有多个参数。


构造器可以重载。
构造器的修饰符只有public、private、protected这三个。
如果没有参数，则会自动生成无参构造器。

父子构造器的调用流程。

什么是单例模式？保证该类只有一个实例。
	实现：用private修饰构造方法，开放一个public方法，
	如果没有实例化，就实例化并保存，如果有了，直接返回。

http://www.mindviewinc.com/Books/TIJ4/PurchaseBook.php

父子构造器执行顺序，new时发生的事件，
	1父类静态语句块；
	2.父类构造函数；
	3.子类静态语句块；
	4.子类构造器



===========================================
v0.0.4-9 OOP 内部类  《21天学通Java》(P266-P297)
http://www.tuicool.com/articles/n2aYra7

内部类：
1.内部类能访问外围类的所有成员，包括私有成员。
	①生成内部类对象，必须要先有外围类对象，具体的做法请见代码；
	②内部类能访问外围类的私有成员
	
2.内部类与static	
	①内部类不能含有static方法；
	②内部类不能含有static数据成员，除非是static final；
	③内部类可以继承含有static成员的类。
	
3.匿名内部类
class D {}
abstract class E {}

class Z extends D {
  E makeE() { return new E() {}; }
}

本质上就是返回以实例化的一个抽象类的后代类。



4. 内部类允许继承多个非接口类型
？？内部类和接口双剑合璧，给出了java中多重继承的完美替代方案？？

5.内部类继承

6.静态内部类



问题：
	•非静态内部类和如何进行非静态内部类和外部类之间的访问。 
	•局部内部类和如何进行局部内部类和外部类之间的访问。 
	•静态内部类和如何进行静态内部类和外部类之间的访问。 
	•匿名内部类和如何进行匿名内部类和外部类之间的访问。









===========================================
v0.0.4-10 异常处理  《21天学通Java》(P240-P265)


• 了解什么是异常处理。 
• 熟练掌握如何进行异常处理。 
• 掌握异常的分类和区别不同的异常。 
• 能够自定义异常和使用自定义异常。

异常的分类：
	捕获异常
	未捕获异常
	
所有的异常类都是继承Throwable类，Throwable类有两个直接子类，Error类和Exception类。
在Exception类中又有一个RuntimeException类。
在Exception类中的直接和间接子类中除去RuntimeException类的直接和间接子类，都是捕获异常。
其他的都为未捕获异常。

try-catch-finally

抛出异常：汇报给上层处理。如果一直不能解决，最后就回抛给main方法，就会中断。

throws语句是在方法的声明中使用来抛出异常，
而throw语句是在方法体内使用抛出异常。

在Exception类中定义很多方法，这里讲解一些最常见的方法。
	使用printStackTrace方法可以显示异常调用栈的信息。
	使用toString方法可以得到异常对象的字符串表示。
	使用getMessage方法可以得到异常对象中携带的出错信息。
	在自定义的异常类中因为继承了Exception类，所以同时拥有这些方法。


如果继承中有重写且抛出异常，父类方法抛出的Exception要大于同名子类方法抛出的Exception。









===========================================
v0.0.5 多线程  《21天学通Java》(P298-P326)

定义线程有两种方法，一种是继承Thread类，一种是实现Runnable接口，这两种方法是存在各自优缺点的。
和定义线程对应的就是创建线程对象，也是有两种方法


定义一个线程可以通过继承Thread类来实现，这是一种相对简单的定义线程的方法。
在Thread类中具有一个run方法，在定义的线程中需要重写这个方法。
在重写的run方法中，可以定义该线程所要执行的语句。
当线程启动时，run方法中的程序就成为一条独立的执行线程。


线程的生命周期分为五种不同的状态，分别是新建状态、准备状态、运行状态、等待/阻塞状态和死亡状态。
	- 处于新建状态中的线程被调用start方法后就会进入准备状态。
	- 从新建状态中只能进入准备状态，并且不能从其他状态进行新建状态。
	- 处于准备状态下的线程随时都可能被系统选择进入运行状态，从而执行线程。
	- 在等待/阻塞状态中的线程被解除等待和阻塞后将不直接进入运行状态，而是首先进入准备状态，
		让系统来选择哪一个线程进入运行状态。


线程优先级 public final void setPriority(int i);


public static void yield(); •可以看出yield让步方法是一个静态方法，
当在正在运行的线程中运行该方法时，该线程将回到准备状态。


太简单：没有讨论锁、死锁、共享变量、线程安全等话题。













===========================================
v0.0.6 GUI  《21天学通Java》(P327-P413)
	Swing是一门开发桌面程序的技术。

	窗口类、面板类、标签类和按钮类
	事件
	
	布局管理器
	
	常用控件：除了按钮，还包括文本框、复选框、单选按钮、选项卡、分割窗格、滑块、滚动条、列表框和菜单
	













