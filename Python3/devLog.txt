Python3学习笔记：目录略详细版

>v0.1.0 IO：序列化和反序列化，pickle和json模块，前者编码更少，后者更通用，推荐用后者。

>v0.1.1 多进程; 
		fork()返回两次！
		把当前进程复制一份，在父子进程中分别返回。
		在父进程中返回子进程id，在子进程返回0.
		子进程获取父进程id号可以通过getppid()获取。
		
import os

print('Process (%s) start...' % os.getpid())
# Only works on Unix/Linux/Mac:
pid = os.fork()
if pid == 0:
    print('I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid()))
else:
    print('I (%s) just created a child process (%s).' % (os.getpid(), pid))


运行结果如下：

Process (876) start...
I (876) just created a child process (877).
I am child process (877) and my parent is 876.

对Pool对象调用join()方法会等待所有子进程执行完毕，
调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。


请注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：

p = Pool(5)就可以同时跑5个进程。
由于Pool的默认大小是CPU的核数，如果你不幸拥有8核CPU，你要提交至少9个子进程才能看到上面的等待效果。

小结：
	在Unix/Linux下，可以使用fork()调用实现多进程。
	要实现跨平台的多进程，可以使用multiprocessing模块。
	进程间通信是通过Queue、Pipes等实现的。
	
	
>v0.1.2 多线程
	threading.Thread(target=loop, name='LoopThread')
	
	锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，
	坏处当然也很多，
		- 首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。
		- 其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，
			导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。
	
	小结
	多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。
	Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。
	
	多个线程，都利用 StringIO往内存中 存取 数据，会不会出现 数据混乱的现象？会。
	
	time在多进程中的应用

	time.time()     返回当前时间戳，
	start=time.time()表示现在开始；
	end=time.time()指的是现在结束。（注意，两个现在指的不是同一时间）
	
	time.sleep(t)     t=推迟执行的秒数


	#ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，
	#这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。




>v0.1.3 分布式计算
	基本形态 
	分布式进程
	(1)day10/task_master.py 在Ubuntu上添加文件头，先运行。
#!/usr/bin/python
# -*- coding: utf-8 -*-
	
	(2)day10/task_worker.py 在win7上接着运行。


	而Queue之所以能通过网络访问，就是通过QueueManager实现的。
	由于QueueManager管理的不止一个Queue，所以，要给每个Queue的网络调用接口起个名字，比如get_task_queue。
	
	authkey有什么用？这是为了保证两台机器正常通信，不被其他机器恶意干扰。
	如果task_worker.py的authkey和task_master.py的authkey不一致，肯定连接不上。
	
	小结
	Python的分布式进程接口简单，封装良好，适合需要把繁重任务分布到多台机器的环境下。
	注意Queue的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。
	比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，
	而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。

